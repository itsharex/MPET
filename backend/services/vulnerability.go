package services

import (
	"MPET/backend/models"
	"database/sql"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// VulnerabilityService 漏洞信息服务
type VulnerabilityService struct {
	db *sql.DB
}

// NewVulnerabilityService 创建漏洞信息服务
func NewVulnerabilityService(db *sql.DB) *VulnerabilityService {
	return &VulnerabilityService{db: db}
}

// InitDefaultVulnerabilities 初始化默认漏洞信息
func (s *VulnerabilityService) InitDefaultVulnerabilities() error {
	// 检查是否已有数据
	var count int
	err := s.db.QueryRow("SELECT COUNT(*) FROM vulnerabilities").Scan(&count)
	if err != nil {
		return err
	}
	if count > 0 {
		return nil // 已有数据，不需要初始化
	}

	// 统一的修复建议模板
	commonRepair := "1. 设置复杂密码（至少 16 位，包含大小写字母、数字和特殊字符）\\n2. 配置防火墙规则，限制访问来源 IP\\n3. 修改默认端口\\n4. 定期更换密码\\n5. 启用访问日志审计\\n6. 及时更新到最新版本"

	// 创建默认漏洞信息
	defaultVulns := []models.VulnerabilityInfo{
		// ========== 弱口令漏洞模板（所有有认证的服务） ==========
		{
			ID:          uuid.New().String(),
			ServiceType: "Redis_Weak",
			Name:        "Redis 弱口令漏洞",
			Level:       "高危",
			Description: "目标 Redis 服务使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取访问权限，读取、修改或删除缓存数据，甚至利用 config 命令写入文件，通过写入 SSH 公钥、定时任务等方式获取服务器权限。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "MySQL_Weak",
			Name:        "MySQL 弱口令漏洞",
			Level:       "高危",
			Description: "目标 MySQL 数据库使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取数据库访问权限，进而获取、修改、删除数据库中的敏感数据，甚至通过 UDF 提权、写入 webshell 等方式获取服务器权限。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "PostgreSQL_Weak",
			Name:        "PostgreSQL 弱口令漏洞",
			Level:       "高危",
			Description: "目标 PostgreSQL 数据库使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取数据库访问权限，进而获取、修改、删除数据库中的敏感数据，甚至通过执行系统命令等方式获取服务器权限。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "MongoDB_Weak",
			Name:        "MongoDB 弱口令漏洞",
			Level:       "高危",
			Description: "目标 MongoDB 数据库使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取数据库访问权限，读取、修改、删除数据库中的数据，造成数据泄露或业务中断。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "SQLServer_Weak",
			Name:        "SQL Server 弱口令漏洞",
			Level:       "高危",
			Description: "目标 SQL Server 数据库使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取数据库访问权限，进而获取、修改、删除数据库中的敏感数据，甚至通过 xp_cmdshell 等存储过程执行系统命令获取服务器权限。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "Oracle_Weak",
			Name:        "Oracle 弱口令漏洞",
			Level:       "高危",
			Description: "目标 Oracle 数据库使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取数据库访问权限，进而获取、修改、删除数据库中的敏感数据，甚至通过 Java 存储过程等方式获取服务器权限。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "FTP_Weak",
			Name:        "FTP 弱口令漏洞",
			Level:       "高危",
			Description: "目标 FTP 服务使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取 FTP 访问权限，获取、上传、修改、删除服务器上的文件，可能导致敏感信息泄露或网站被植入后门。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "SFTP_Weak",
			Name:        "SFTP 弱口令漏洞",
			Level:       "高危",
			Description: "目标 SFTP 服务使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取 SFTP 访问权限，获取、上传、修改、删除服务器上的文件，可能导致敏感信息泄露或系统被入侵。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "SMB_Weak",
			Name:        "SMB 弱口令漏洞",
			Level:       "高危",
			Description: "目标 SMB 服务使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取共享文件夹访问权限，读取、修改或删除文件，甚至通过 SMB 漏洞获取系统权限。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "SSH_Weak",
			Name:        "SSH 弱口令漏洞",
			Level:       "高危",
			Description: "目标 SSH 服务使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取服务器登录权限，进而完全控制目标服务器，执行任意命令，窃取敏感数据，或将服务器作为跳板攻击内网其他主机。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "RDP_Weak",
			Name:        "RDP 弱口令漏洞",
			Level:       "高危",
			Description: "目标 RDP（远程桌面）服务使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取远程桌面访问权限，完全控制目标服务器，窃取敏感数据或植入恶意软件。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "VNC_Weak",
			Name:        "VNC 弱口令漏洞",
			Level:       "高危",
			Description: "目标 VNC 服务使用了弱口令（密码：{password}），攻击者可以通过暴力破解获取远程桌面访问权限，完全控制目标系统，窃取敏感信息或进行恶意操作。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "WMI_Weak",
			Name:        "WMI 弱口令漏洞",
			Level:       "高危",
			Description: "目标 WMI（Windows Management Instrumentation）服务使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取 WMI 访问权限，远程执行命令，查询系统信息，甚至完全控制目标系统。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "RabbitMQ_Weak",
			Name:        "RabbitMQ 弱口令漏洞",
			Level:       "高危",
			Description: "目标 RabbitMQ 服务使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取 RabbitMQ 管理界面访问权限，获取消息队列中的敏感数据，或者通过消息队列进行进一步的攻击。",
			Repair:      commonRepair,
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "MQTT_Weak",
			Name:        "MQTT 弱口令漏洞",
			Level:       "高危",
			Description: "目标 MQTT 服务使用了弱口令（用户名：{username}，密码：{password}），攻击者可以通过暴力破解获取 MQTT 访问权限，订阅或发布消息，窃取物联网设备数据或控制设备。",
			Repair:      commonRepair,
		},
		// ========== 未授权访问漏洞模板（真正的未授权服务） ==========
		{
			ID:          uuid.New().String(),
			ServiceType: "Redis_Unauth",
			Name:        "Redis 未授权访问漏洞",
			Level:       "高危",
			Description: "目标 Redis 服务未启用认证保护，允许任意用户未授权访问。攻击者可以直接连接 Redis 服务，读取、修改或删除缓存数据，甚至利用 config 命令写入文件，通过写入 SSH 公钥、定时任务等方式获取服务器权限。",
			Repair:      "1. 配置 requirepass 选项，设置复杂密码\\n2. 配置 bind 选项，限定可以连接的 IP\\n3. 配置防火墙规则，限制访问端口\\n4. 禁用或重命名危险命令（如 FLUSHALL、FLUSHDB、CONFIG、KEYS 等）\\n5. 以低权限用户运行 Redis\\n6. 定期审计访问日志",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "Memcached_Unauth",
			Name:        "Memcached 未授权访问漏洞",
			Level:       "中危",
			Description: "目标 Memcached 服务未启用认证保护，允许任意用户未授权访问。攻击者可以直接连接 Memcached 服务，读取缓存中的敏感数据（如 Session、用户信息等），或者利用 Memcached 进行 DDoS 反射攻击。",
			Repair:      "1. 启用 SASL 认证\\n2. 绑定到本地回环地址（127.0.0.1）\\n3. 配置防火墙规则，禁止外网访问\\n4. 禁用 UDP 协议（防止反射攻击）\\n5. 使用最新版本的 Memcached\\n6. 定期审计访问日志",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "MongoDB_Unauth",
			Name:        "MongoDB 未授权访问漏洞",
			Level:       "高危",
			Description: "目标 MongoDB 数据库未启用认证保护，允许任意用户未授权访问。攻击者可以直接连接 MongoDB 数据库，读取、修改、删除数据库中的数据，造成数据泄露或业务中断。",
			Repair:      "1. 启用身份认证（--auth 参数）\\n2. 创建管理员账户并设置复杂密码\\n3. 配置 bindIp 选项，限制访问来源\\n4. 配置防火墙规则，限制 MongoDB 端口访问\\n5. 禁用 HTTP 状态接口\\n6. 定期更新 MongoDB 版本\\n7. 定期审计访问日志",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "Elasticsearch_Unauth",
			Name:        "Elasticsearch 未授权访问漏洞",
			Level:       "高危",
			Description: "目标 Elasticsearch 服务未启用认证保护，允许任意用户未授权访问。攻击者可以直接访问 Elasticsearch，读取、修改、删除索引数据，甚至通过脚本执行等方式获取服务器权限。",
			Repair:      "1. 启用 X-Pack 安全功能（或使用 Search Guard 等插件）\\n2. 配置用户认证和角色权限\\n3. 配置防火墙规则，限制访问来源\\n4. 禁用动态脚本执行\\n5. 配置 SSL/TLS 加密传输\\n6. 定期更新 Elasticsearch 版本\\n7. 定期审计访问日志",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "Docker_Unauth",
			Name:        "Docker API 未授权访问漏洞",
			Level:       "高危",
			Description: "目标 Docker Remote API 未启用认证保护，允许任意用户未授权访问。攻击者可以直接访问 Docker API，获取容器信息、镜像信息，甚至可以创建特权容器挂载宿主机目录，进而完全控制宿主机系统。",
			Repair:      "1. 启用 TLS 认证\\n2. 不要将 Docker API 暴露在公网\\n3. 使用防火墙限制访问来源\\n4. 使用 Docker Socket 代理（如 Tecnativa/docker-socket-proxy）\\n5. 限制容器的权限，避免使用 --privileged 参数\\n6. 定期更新 Docker 版本\\n7. 定期审计 Docker 操作日志",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "Kubernetes_Unauth",
			Name:        "Kubernetes API 未授权访问漏洞",
			Level:       "高危",
			Description: "目标 Kubernetes API Server 未启用认证保护，允许任意用户未授权访问。攻击者可以直接访问 API Server，获取集群信息、Pod 信息、Secret 等敏感数据，甚至可以创建特权 Pod 获取节点权限，进而控制整个 Kubernetes 集群。",
			Repair:      "1. 启用 RBAC 权限控制\\n2. 禁用匿名访问（--anonymous-auth=false）\\n3. 配置 TLS 客户端证书认证\\n4. 不要将 API Server 暴露在公网\\n5. 配置网络策略，限制 Pod 间通信\\n6. 使用 Pod Security Policy 限制 Pod 权限\\n7. 定期审计 API Server 访问日志",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "Zookeeper_Unauth",
			Name:        "Zookeeper 未授权访问漏洞",
			Level:       "中危",
			Description: "目标 Zookeeper 服务未启用认证保护，允许任意用户未授权访问。攻击者可以直接连接 Zookeeper，读取配置信息、服务注册信息等敏感数据，或者修改配置导致服务异常。",
			Repair:      "1. 启用 SASL 认证\\n2. 配置 ACL 权限控制\\n3. 配置防火墙规则，限制访问来源\\n4. 修改默认端口（2181）\\n5. 禁用四字命令（或限制访问）\\n6. 定期更新 Zookeeper 版本\\n7. 定期审计访问日志",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "Etcd_Unauth",
			Name:        "Etcd 未授权访问漏洞",
			Level:       "高危",
			Description: "目标 Etcd 服务未启用认证保护，允许任意用户未授权访问。攻击者可以直接访问 Etcd，读取、修改配置数据，可能导致服务配置被篡改或敏感信息泄露。",
			Repair:      "1. 启用客户端证书认证\\n2. 启用 RBAC 权限控制\\n3. 配置防火墙规则，限制访问来源\\n4. 使用 TLS 加密通信\\n5. 不要将 Etcd 暴露在公网\\n6. 定期更新 Etcd 版本\\n7. 定期审计访问日志",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "Kafka_Unauth",
			Name:        "Kafka 未授权访问漏洞",
			Level:       "中危",
			Description: "目标 Kafka 服务未启用认证保护，允许任意用户未授权访问。攻击者可以直接连接 Kafka，订阅或发布消息，窃取消息队列中的敏感数据或干扰业务正常运行。",
			Repair:      "1. 启用 SASL 认证\\n2. 配置 ACL 权限控制\\n3. 配置防火墙规则，限制访问来源\\n4. 使用 SSL/TLS 加密通信\\n5. 不要将 Kafka 暴露在公网\\n6. 定期更新 Kafka 版本\\n7. 定期审计访问日志",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "ADB_Unauth",
			Name:        "ADB 未授权访问漏洞",
			Level:       "高危",
			Description: "目标 ADB（Android Debug Bridge）服务未启用认证保护，允许任意用户未授权访问。攻击者可以直接连接 ADB，完全控制 Android 设备，安装应用、读取数据、执行命令等。",
			Repair:      "1. 禁用 ADB 网络调试功能\\n2. 启用 ADB 认证（使用 RSA 密钥对）\\n3. 配置防火墙规则，限制 ADB 端口访问\\n4. 仅在必要时开启 ADB\\n5. 定期检查已授权的 ADB 密钥\\n6. 使用 USB 调试替代网络调试",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "JDWP_Unauth",
			Name:        "JDWP 未授权访问漏洞",
			Level:       "高危",
			Description: "目标 JDWP（Java Debug Wire Protocol）服务未启用认证保护，允许任意用户未授权访问。攻击者可以通过 JDWP 协议远程调试 Java 应用，执行任意代码，完全控制目标系统。",
			Repair:      "1. 生产环境禁用 JDWP 调试功能\\n2. 如必须使用，配置防火墙限制访问来源\\n3. 使用 SSH 隧道访问 JDWP\\n4. 修改默认调试端口\\n5. 定期检查是否有意外开启的调试端口\\n6. 使用 JVM 参数限制调试连接来源",
		},
		{
			ID:          uuid.New().String(),
			ServiceType: "RMI_Unauth",
			Name:        "RMI 未授权访问漏洞",
			Level:       "高危",
			Description: "目标 RMI（Java Remote Method Invocation）服务未启用认证保护，允许任意用户未授权访问。攻击者可以通过 RMI 协议调用远程方法，可能导致反序列化漏洞利用，执行任意代码。",
			Repair:      "1. 启用 RMI 认证和授权\\n2. 配置防火墙规则，限制 RMI 端口访问\\n3. 使用 SSL/TLS 加密 RMI 通信\\n4. 禁用不必要的 RMI 服务\\n5. 更新 JDK 版本，修复已知漏洞\\n6. 使用 JEP 290 限制反序列化类\\n7. 定期审计 RMI 访问日志",
		},
	}

	// 批量插入
	tx, err := s.db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()

	stmt, err := tx.Prepare(`
		INSERT INTO vulnerabilities (id, service_type, name, level, description, repair, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	`)
	if err != nil {
		return err
	}
	defer stmt.Close()

	now := time.Now().Format(time.RFC3339)
	for _, vuln := range defaultVulns {
		_, err := stmt.Exec(
			vuln.ID,
			vuln.ServiceType,
			vuln.Name,
			vuln.Level,
			vuln.Description,
			vuln.Repair,
			now,
			now,
		)
		if err != nil {
			return fmt.Errorf("插入漏洞信息失败: %v", err)
		}
	}

	return tx.Commit()
}

// GetAll 获取所有漏洞信息
func (s *VulnerabilityService) GetAll() ([]models.VulnerabilityInfo, error) {
	rows, err := s.db.Query(`
		SELECT id, service_type, name, level, description, repair, created_at, updated_at
		FROM vulnerabilities
		ORDER BY service_type
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var vulns []models.VulnerabilityInfo
	for rows.Next() {
		var vuln models.VulnerabilityInfo
		var createdAtStr, updatedAtStr string

		err := rows.Scan(
			&vuln.ID,
			&vuln.ServiceType,
			&vuln.Name,
			&vuln.Level,
			&vuln.Description,
			&vuln.Repair,
			&createdAtStr,
			&updatedAtStr,
		)
		if err != nil {
			return nil, err
		}

		if createdAtStr != "" {
			if t, err := time.Parse(time.RFC3339, createdAtStr); err == nil {
				vuln.CreatedAt = t
			}
		}
		if updatedAtStr != "" {
			if t, err := time.Parse(time.RFC3339, updatedAtStr); err == nil {
				vuln.UpdatedAt = t
			}
		}

		vulns = append(vulns, vuln)
	}

	return vulns, rows.Err()
}

// GetByServiceType 根据服务类型获取漏洞信息
func (s *VulnerabilityService) GetByServiceType(serviceType string) (*models.VulnerabilityInfo, error) {
	var vuln models.VulnerabilityInfo
	var createdAtStr, updatedAtStr string

	err := s.db.QueryRow(`
		SELECT id, service_type, name, level, description, repair, created_at, updated_at
		FROM vulnerabilities
		WHERE service_type = ?
	`, serviceType).Scan(
		&vuln.ID,
		&vuln.ServiceType,
		&vuln.Name,
		&vuln.Level,
		&vuln.Description,
		&vuln.Repair,
		&createdAtStr,
		&updatedAtStr,
	)

	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	if createdAtStr != "" {
		if t, err := time.Parse(time.RFC3339, createdAtStr); err == nil {
			vuln.CreatedAt = t
		}
	}
	if updatedAtStr != "" {
		if t, err := time.Parse(time.RFC3339, updatedAtStr); err == nil {
			vuln.UpdatedAt = t
		}
	}

	return &vuln, nil
}

// Save 保存漏洞信息
func (s *VulnerabilityService) Save(vuln *models.VulnerabilityInfo) error {
	now := time.Now().Format(time.RFC3339)

	if vuln.ID == "" {
		// 新增
		vuln.ID = uuid.New().String()
		_, err := s.db.Exec(`
			INSERT INTO vulnerabilities (id, service_type, name, level, description, repair, created_at, updated_at)
			VALUES (?, ?, ?, ?, ?, ?, ?, ?)
		`, vuln.ID, vuln.ServiceType, vuln.Name, vuln.Level, vuln.Description, vuln.Repair, now, now)
		return err
	}

	// 更新
	_, err := s.db.Exec(`
		UPDATE vulnerabilities
		SET service_type = ?, name = ?, level = ?, description = ?, repair = ?, updated_at = ?
		WHERE id = ?
	`, vuln.ServiceType, vuln.Name, vuln.Level, vuln.Description, vuln.Repair, now, vuln.ID)
	return err
}

// Delete 删除漏洞信息
func (s *VulnerabilityService) Delete(id string) error {
	_, err := s.db.Exec("DELETE FROM vulnerabilities WHERE id = ?", id)
	return err
}
